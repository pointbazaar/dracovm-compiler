package org.vanautrui.languages.vmcompiler.codegenerator;

import org.vanautrui.languages.vmcompiler.AssemblyWriter;
import org.vanautrui.languages.vmcompiler.VMCompilerPhases;
import org.vanautrui.languages.vmcompiler.instructions.VMInstr;
import org.vanautrui.languages.vmcompiler.model.Register;

import static org.vanautrui.languages.vmcompiler.codegenerator.StackFocusedAssemblyCodeGenerator.compile_push;
import static org.vanautrui.languages.vmcompiler.codegenerator.StackFocusedAssemblyCodeGenerator.compile_swap;
import static org.vanautrui.languages.vmcompiler.model.Register.*;

/**
 * contains the builtin subroutines of dragon, in assembly.
 * These subroutines are to be added at the end of the code to every .asm file generated by the dragon vm compiler.
 *
 * These subroutines must behave like any other subroutine when called.
 */

final class BuiltinSubroutinesInAssembly {

  //https://www.informatik.htw-dresden.de/~beck/ASM/syscall_list.html

  //eax values (syscall numbers):
  private static final int SYS_EXIT   = 1;
  private static final int SYS_FORK   = 2;
  private static final int SYS_READ   = 3;
  private static final int SYS_WRITE  = 4;
  private static final int SYS_OPEN   = 5;
  private static final int SYS_CLOSE  = 6;
  private static final int SYS_WAITPID= 7;
  private static final int SYS_CREAT  = 8;
  //..
  private static final int SYS_TIME   = 13;
  //..

  /**
   * Compiles all builtin subroutines.
   * This is so that we can call this subroutine in assembly code generation,
   * and do not forget a subroutine.
   * So a new subroutine can be added easily
   */
  static void compile_all_builtin_subroutines(final AssemblyWriter a) {
    compile_readchar(a);
    compile_putchar(a);
    compile_putdigit(a);

    compile_new(a);
    compile_free(a);

    compile_len(a);

    //we need abs (Math.abs(x), the absolute value of an Integer ) as a builtin subroutine.
    compile_abs(a);

    //to get the system time
    compile_time(a);

    compile_fopen(a);
    compile_fputs(a);
  }

  private static void compile_fputs(final AssemblyWriter a){
    //https://www.tutorialspoint.com/c_standard_library/c_function_fputs.htm

    //([Char] str, Pint filedescriptor)~>PInt
    //arg 0: string to write
    //arg 1: filedescriptor of the file to write to
    //returns: 0

    //prints a string to a file

    SubroutineFocusedAssemblyCodeGenerator.compile_subroutine("Builtin_fputs",a);

    //access our argument , ARG 0, by pushing it onto the stack
    compile_push(VMCompilerPhases.SEGMENT_ARG,0,a);

    //access our argument , ARG 1, by pushing it onto the stack
    compile_push(VMCompilerPhases.SEGMENT_ARG,1,a);

    a.mov(eax,SYS_WRITE,"fputs: sys_write");

    a.pop(ebx,"fputs: pop our filedescriptor argument");

    //print the char on stack
    a.pop(ecx,"fputs: pop our string to write argument");

    a.mov(edx,ecx,"fputs: how many bytes to write");
    a.dereference(edx,"fputs: how many bytes to write");

    a.add(ecx, byte_offset_32bit,"fputs: offset the pointer to start of string.");

    a.call_kernel();

    //push return value
    a.push(0,"fputs: push return value");

    //we must swap return value with the return address in order to return
    //(i am so dumb. took me so long to find this.)
    compile_swap("swap return address with return value to return",a);

    //return from subroutine
    SubroutineFocusedAssemblyCodeGenerator.compile_return(a);
  }

  private static void compile_fopen(final AssemblyWriter a) {
    // ([Char] filename ,PInt accessmode)~>PInt fopen
    //takes 2 arguments: the file name ([Char]), and the access mode (PInt)
    //returns a file descriptor (PInt) which can then be used with fputs to write to a file

    SubroutineFocusedAssemblyCodeGenerator.compile_subroutine("Builtin_fopen",a);

    //access our argument , ARG 1, by pushing it onto the stack
    compile_push(VMCompilerPhases.SEGMENT_ARG,1,a);

    //access our argument , ARG 0, by pushing it onto the stack
    compile_push(VMCompilerPhases.SEGMENT_ARG,0,a);

    //stack:
    //accessmode
    //filename <- esp

    a.mov(eax,SYS_OPEN,"fopen: sys_open");
    a.pop(ebx,"fopen: get the filename [Char] pointer");

    //tood : we should get the syntactic sugar with the strings in dragon
    //to insert a nullbyte at the end. or use a specially prepared string with this syscall
    //because it is a c-style syscall, it expects a '\0' at the end of the filename probably
    //https://stackoverflow.com/questions/8312290/how-to-open-a-file-in-assembler-and-modify-it

    a.add(ebx, byte_offset_32bit,"offset to the start, as arrays are length-prefixed in dragon");
    //ebx now contains the filename argument
    a.pop(ecx,"fopen: access mode");


    a.call_kernel();

    //push return value
    a.push(eax,"fopen: push return value (file descriptor in eax)");

    //we must swap return value with the return address in order to return
    //(i am so dumb. took me so long to find this.)
    compile_swap("swap return address with return value to return",a);

    //return from subroutine
    SubroutineFocusedAssemblyCodeGenerator.compile_return(a);
  }

  private static void compile_time(AssemblyWriter a) {
    //time in seconds since the epoch
    //https://fresh.flatassembler.net/lscr/

    //takes 0 arguments
    //returns a PInt

    SubroutineFocusedAssemblyCodeGenerator.compile_subroutine("Builtin_time",a);

    a.mov(eax,SYS_TIME,"time: sys_time");
    a.mov(ebx,0,"time: return time only in eax");
    a.xor(ecx,ecx,"");
    a.xor(edx,edx,"");
    a.call_kernel();


    //push return value
    a.push(eax,"time: push return value");

    //we must swap return value with the return address in order to return
    //(i am so dumb. took me so long to find this.)
    compile_swap("swap return address with return value to return",a);

    //return from subroutine
    SubroutineFocusedAssemblyCodeGenerator.compile_return(a);
  }

  private static void compile_abs(final AssemblyWriter a) {
    //receives 1 integer as an argument (x)
    //returns the absolute value of an integer

    SubroutineFocusedAssemblyCodeGenerator.compile_subroutine("Builtin_abs",a);

    //access our argument , ARG 0, by pushing it onto the stack
    compile_push(VMCompilerPhases.SEGMENT_ARG,0,a);

    //pointer is now on stack
    a.pop(eax);

    a.mov(ebx,eax);
    a.mov(ecx,-1);
    a.mul_eax_with(ecx);

    //eax = -x
    //ebx = x
    a.mov(edx,0);

    a.cmp(eax,edx);
    //if eax=-x>=0, return eax, otherwise return ebx=x
    a.jge(".end","");

    a.mov(eax,ebx);

    a.label(".end");

    //push return value
    a.push(eax);

    //we must swap return value with the return address in order to return
    //(i am so dumb. took me so long to find this.)
    compile_swap("swap return address with return value to return",a);

    //return from subroutine
    SubroutineFocusedAssemblyCodeGenerator.compile_return(a);
  }

  private static void compile_len(final AssemblyWriter a) {
    //returns the length of a length-prefixed memory segment

    SubroutineFocusedAssemblyCodeGenerator.compile_subroutine("Builtin_len",a);

    //access our argument , ARG 0, by pushing it onto the stack
    compile_push(VMCompilerPhases.SEGMENT_ARG,0,a);

    //pointer is now on stack
    a.pop(eax);

    //mov eax,[eax] //get the length stored at that location
    a.dereference(eax);

    //push return value
    a.push(eax);

    //we must swap return value with the return address in order to return
    //(i am so dumb. took me so long to find this.)
    compile_swap("swap return address with return value to return",a);

    //return from subroutine
    SubroutineFocusedAssemblyCodeGenerator.compile_return(a);
  }

  /**
   * reads a single character from stdin
   */
  private static void compile_readchar(final AssemblyWriter a){
    final String name="readchar: ";

    //TODO: handle errors that could occur

    SubroutineFocusedAssemblyCodeGenerator.compile_subroutine("Builtin_readchar",a);

    //push a placeholder for the value to read on the stack
    a.mov(eax,0);
    a.push(eax);

    //SYSCALL START
    a.mov(eax,SYS_READ,name+"sys_read");
    a.mov(ebx,0,name+"stdin");

    //print the char on stack
    a.mov(ecx, esp,name+"read into the placeholder DWORD we pushed onto the stack");

    //val length
    a.mov(edx,1,name+"value length");
    a.call_kernel();
    //SYSCALL END

    //push return value: we do not need to push a return value,
    //as we already pushed a placeholder where our char (which has been read by now)
    // should have been placed

    //we must swap return value with the return address in order to return
    //(i am so dumb. took me so long to find this.)
    compile_swap(name+"swap return address with return value to return",a);

    //return from subroutine
    SubroutineFocusedAssemblyCodeGenerator.compile_return(a);
  }

  private static void compile_free(final AssemblyWriter a){
    final String name = "Builtin_free";
    //TODO: not yet implemented
  }

  private static void compile_new(final AssemblyWriter a) {
    //http://lxr.linux.no/#linux+v3.6/arch/x86/ia32/ia32entry.S#L372
    //http://man7.org/linux/man-pages/man2/mmap.2.html

    //TODO: handle the error if memory could not be allocated
    final String name="new";
    //malloc receives as an argument the amount of DWORDs to allocate

    SubroutineFocusedAssemblyCodeGenerator.compile_subroutine("Builtin_new",a);

    //access our argument, push it onto the stack
    compile_push(VMCompilerPhases.SEGMENT_ARG,0,a);


    //this is to multiply by 4, so we allocate 32bit units.
    a.pop(ecx,"size of segment to be allocated"); //pop our argument into ecx

    //push our size for the length-prefix later on
    a.push(ecx); //LINKED CODE 2 (they only work together)

    //increment by 1, as our array should be length-prefixed, and we need a place to store the length
    a.inc(ecx);

    a.mov(eax,byte_offset_32bit);
    a.mul_eax_with(ecx);
    a.mov(ecx,eax);


    a.mov(eax,192,"192 : mmap system call");
    a.xor(ebx,ebx,"addr=NULL");
    a.mov(edx,0x7,"prot = PROT_READ | PROT_WRITE | PROT_EXEC");
    a.mov(esi,0x22,"flags=MAP_PRIVATE | MAP_ANONYMOUS");
    a.mov(edi,-1,"fd=-1");

    a.push(ebp,"save ebp as we should not mess with it"); //LINKED CODE 1 (they only work together)

    a.mov(ebp,0,"offset=0 (4096*0)");
    a.call_kernel();

    a.pop(ebp,"restore ebp as we should not mess with it"); //LINKED CODE 1 (they only work together)

    //eax should now contain
    //the address of the allocated memory segment

    //put the length-prefix at the start
    //pop our length-prefix
    a.pop(ebx); ////LINKED CODE 2 (they only work together)

    //mov [eax],ebx //store the length at index 0
    a.store_second_into_memory_location_pointed_to_by_first(eax,ebx);

    //now we push that pointer on the stack
    a.push(eax);

    //we must swap return value with the return address in order to return
    //(i am so dumb. took me so long to find this.)
    compile_swap(name+"swap return address with return value to return",a);

    //return from subroutine
    SubroutineFocusedAssemblyCodeGenerator.compile_return(a);
  }

  private static void compile_putchar(final AssemblyWriter a) {
    //prints top of stack as ascii char to stdout

    SubroutineFocusedAssemblyCodeGenerator.compile_subroutine("Builtin_putchar",a);

    //access our argument , ARG 0, by pushing it onto the stack
    compile_push(VMCompilerPhases.SEGMENT_ARG,0,a);

    a.mov(eax,SYS_WRITE,"putchar: sys_write");
    a.mov(ebx,1,"putchar: std_out");

    //print the char on stack
    a.mov(ecx, esp,"putchar: print the char on the stack");


    //val length
    a.mov(edx,1,"putchar: value length");
    a.call_kernel();

    //remove our argument which we had pushed
    a.pop(eax,"putchar: remove the ARG 0 which we had pushed");

    //push return value
    a.mov(edx,0,"putchar: push return value");
    a.push(edx,"putchar: push return value");

    //we must swap return value with the return address in order to return
    //(i am so dumb. took me so long to find this.)
    compile_swap("swap return address with return value to return",a);

    //return from subroutine
    SubroutineFocusedAssemblyCodeGenerator.compile_return(a);
  }

  private static void compile_putdigit(final AssemblyWriter a) {
    //prints the Int on top of stack as char to stdout
    SubroutineFocusedAssemblyCodeGenerator.compile_subroutine("Builtin_putdigit",a);
    final String name="putdigit";

    //access our argument , ARG 0, by pushing it onto the stack
    compile_push(VMCompilerPhases.SEGMENT_ARG,0,a);

    a.mov(eax,SYS_WRITE,name+" sys_write");
    a.mov(ebx,1,name+" std_out");

    //duplicate the value on stack, add offset to make it a char
    a.pop(ecx);
    a.push(ecx);
    a.add(ecx,48,name+" add offset to make it char");
    a.push(ecx);

    a.mov(ecx, esp,name+" print the Int on the stack");

    //val length
    a.mov(edx,1,name+" value length");
    a.call_kernel();

    //pop that value which we pushed
    a.pop(ecx);

    //pop ARG 0 which we pushed
    a.pop(ecx);

    //push return value
    a.mov(edx,0,name+" push return value");
    a.push(edx,name+" push return value");

    //we must swap return value with the return address in order to return
    //(i am so dumb. took me so long to find this.)
    compile_swap("swap return address with return value to return",a);

    SubroutineFocusedAssemblyCodeGenerator.compile_return(a);
  }

  private static void compile_float2int(final VMInstr instr, final AssemblyWriter a) throws Exception{
    throw new Exception("unhandled");
  }

  private static void compile_int2float(final VMInstr instr, final AssemblyWriter a) throws Exception{
    throw new Exception("unhandled");
  }

  private static void compile_int2char(final VMInstr instr, final AssemblyWriter a) throws Exception{
    throw new Exception("unhandled");
  }

  private static void compile_readint(final VMInstr instr, final AssemblyWriter a)throws Exception{
    throw new Exception("unhandled");
  }
}
